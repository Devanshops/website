<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Development-rsses on Choria Orchestrator</title>
    <link>http://docs.choria.io/development/index.xml</link>
    <description>Recent content in Development-rsses on Choria Orchestrator</description>
    <generator>Hugo -- gohugo.io</generator>
    <atom:link href="http://docs.choria.io/development/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Development</title>
      <link>http://docs.choria.io/development/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.choria.io/development/</guid>
      <description>

&lt;h1 id=&#34;development&#34;&gt;Development&lt;/h1&gt;

&lt;p&gt;This section provide development reference information about the plugin internals, you can safely skip this unless you&amp;rsquo;re looking to enhance Choria.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>REST Server Support</title>
      <link>http://docs.choria.io/development/rest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.choria.io/development/rest/</guid>
      <description>&lt;p&gt;In the past several attempts have been made to create REST gateways for MCollective but most of them were not very good.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;They did not set callerids thus the AAA model was broken&lt;/li&gt;
&lt;li&gt;They expect REST clients to wait for the duration of the request and so
 consume many resources internal to them and generally are just a bad fit
 for REST&lt;/li&gt;
&lt;li&gt;MCollective is not pure JSON&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first requires a cooperative Security Plugin, this plugin is one and lets one build a REST gateway that works with the MCollective AAA design.&lt;/p&gt;

&lt;p&gt;The Choria security plugin has specific support for building REST services to interact with MCollective.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;+---------+                           +-------+                         +---------+
| Client  |                           | REST  |                         | Server  |
+---------+                           +-------+                         +---------+
     |                                    |                                  |
     | Obtain Auth Token                  |                                  |
     |-----------------------------------&amp;gt;|                                  |
     |                                    |                                  |
     |                  Stores Auth Token |                                  |
     |&amp;lt;-----------------------------------|                                  |
     |                                    |                                  |
     | MCollective Request with Token     |                                  |
     |-----------------------------------&amp;gt;|                                  |
     |                                    |                                  |
     |                                    | /---------------\                |
     |                                    |-| Internal RBAC |                |
     |                                    | \---------------/                |
     |                                    |                                  |
     |                                    |                                  |
     |                                    | signed with privileged user      |
     |                                    | cert sets token based callerid   |
     |                                    |---------------------------------&amp;gt;|
     |                                    |                                  |
     |                          RequestID |                                  |
     |&amp;lt;-----------------------------------|                                  |
     |                                    |                                  | /-----------------------\
     |                                    |                                  |-| AAA based on callerid |
     |                                    |                                  | \-----------------------/
     |                                    |                                  |
     |                                    |                           result |
     |                 /---------------\  |&amp;lt;---------------------------------|
     |                 | Stores results |-|                           result |
     |                 |  in a database | |&amp;lt;---------------------------------|
     |                 \-------------- /  |                           result |
     |                                    |&amp;lt;---------------------------------|
     |                                    |                                  |
     | Request results for RequestID      |                                  |
     |-----------------------------------&amp;gt;|                                  |
     |                                    | /------------------\             |
     |                                    |-|Retrieves from DB |             |
     |                                    | \------------------/             |
     |           Result set for RequestID |                                  |
     |&amp;lt;-----------------------------------|                                  |
     |                                    |                                  |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the REST service has it&amp;rsquo;s own token based authentication - perhaps OAth or similar, and would have an internal username schema for it&amp;rsquo;s users.&lt;/p&gt;

&lt;p&gt;It would have a MCollective certificate that&amp;rsquo;s considered a Privileged User certificate and so can set the &lt;em&gt;callerid&lt;/em&gt; to any value it likes.  To MCollective the &lt;em&gt;callerid&lt;/em&gt; would be _choria=uid_set_by&lt;em&gt;rest&lt;/em&gt; where AAA can happen.&lt;/p&gt;

&lt;p&gt;This way the REST gateway can do it&amp;rsquo;s own RBAC, caching, security model etc and with the model above the clients do not need to wait - results spool back from a database, can be paged and retrieved at any later date&lt;/p&gt;

&lt;p&gt;To set this up the REST service would get it&amp;rsquo;s own SSL certs as any other clients and nodes would need to be specifically configured to trust the REST gateway as a &lt;em&gt;Privileged User&lt;/em&gt; capable of setting &lt;em&gt;callerid&lt;/em&gt; != &lt;em&gt;certname&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;By default any certificate matching &lt;em&gt;/.privileged.mcollective$/&lt;/em&gt; will be a privileged user but you can specificy a list like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;plugin.choria.security.privileged_users = rest_gateway_1.mcollective, rest_gateway_2.mcollective
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MCollective is still not pure JSON but this might change in the near future.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Message Structure</title>
      <link>http://docs.choria.io/development/messages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.choria.io/development/messages/</guid>
      <description>

&lt;h2 id=&#34;message-protocol-details&#34;&gt;Message Protocol Details&lt;/h2&gt;

&lt;p&gt;Below this is just developer details, you can easily skip this unless you&amp;rsquo;re curious.&lt;/p&gt;

&lt;p&gt;MCollective messages are made up of layers of encoded messages, generally something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;( middleware protocol
  ( transport packet that travels over the middleware
      ( security plugin internal representation
        ( mcollective core representation that becomes M::Message
          ( message body, for RPC request M::RPC::Request and M::RPC::Reply )
        )
      )
    )
  )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is very similar how on the internet REST is within HTTP within TCP within IP and
eventually within transport specific layers like for Ethernet or WAN protocols.&lt;/p&gt;

&lt;p&gt;By doing it this way many end points like the &lt;code&gt;Mcollective::RPC&lt;/code&gt; can cohabit in
the same system (just like HTTP and FTP can on the intenret), security layers can
be swapped out with different ones ie. the &lt;code&gt;ssl&lt;/code&gt; and &lt;code&gt;aes&lt;/code&gt; ones and indeed this
one based on &lt;code&gt;puppet&lt;/code&gt; PKI.&lt;/p&gt;

&lt;p&gt;The security system receives or send serialized packets via the middleware layer
which again is a series of plugins - like &lt;code&gt;activemq&lt;/code&gt; or &lt;code&gt;rabbitmq&lt;/code&gt; and these have
their own protocols which allow it to swap out the transport between nodes with
different technology.&lt;/p&gt;

&lt;p&gt;In most security plugins the 3rd and 4th layers are combined, but this plugin is
proposing a future core format so right now there&amp;rsquo;s a split, so we have:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;( Stomp, AMQP, NATS etc
  ( JSON encoded mcollective::security::choria:request:1 or mcollective::security::choria:reply:1
      ( encoded mcollective:request:3 or mcollective:reply:3
        ( mcollective core as per #to_legacy_request and #to_legacy_reply
          ( message body, for RPC request M::RPC::Request and M::RPC::Reply )
        )
      )
    )
  )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;mcollective core representation that becomes M::Message&lt;/code&gt; layer will go away
eventually and be replaced wtih &lt;code&gt;mcollective:request:3&lt;/code&gt; and &lt;code&gt;mcollective:reply:3&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-note-on-serialization&#34;&gt;A note on serialization&lt;/h3&gt;

&lt;p&gt;Right now the MCollective core has unfortunately exposed Ruby Symbols to the wire,
worse they are not a standard or required and in many cases it&amp;rsquo;s up to the users
to use them or strings.  This means standard JSON cannot be used to encode the
core message and a one size fits all translation layer cannot be written.&lt;/p&gt;

&lt;p&gt;So the message structures &lt;code&gt;mcollective:request:3&lt;/code&gt; and &lt;code&gt;mcollective:reply:3&lt;/code&gt; today
hosts in their &lt;code&gt;message&lt;/code&gt; property a core MCollective message with potentially
Symbols in it&amp;rsquo;s body.&lt;/p&gt;

&lt;p&gt;So we have to use YAML to serialize these messages.  A critical future goal for mc
is to downgrade the RPC system to only support JSON primitives and to change the
internal message structures to use Strings as keys.&lt;/p&gt;

&lt;p&gt;At that point the entire payload will use JSON only and no YAML. And one of the
layers above will go away.&lt;/p&gt;

&lt;h3 id=&#34;puppet-security-plugin-request&#34;&gt;Puppet Security Plugin Request&lt;/h3&gt;

&lt;p&gt;The following is a request encoded for delivery using the communication plugins, it
will be JSON encoded before sending:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;$schema&amp;quot;: &amp;quot;http://json-schema.org/draft-04/schema#&amp;quot;,
  &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
  &amp;quot;properties&amp;quot;: {
    &amp;quot;protocol&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
      &amp;quot;enum&amp;quot;: [
        &amp;quot;mcollective::security::choria:request:1&amp;quot;
      ]
    },
    &amp;quot;message&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
      &amp;quot;description&amp;quot;: &amp;quot;YAML encoded mcollective:request:3&amp;quot;
    },
    &amp;quot;signature&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
      &amp;quot;description&amp;quot;: &amp;quot;SHA256 based signature of the message using the senders private key&amp;quot;
    },
    &amp;quot;pubcert&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
      &amp;quot;description&amp;quot;: &amp;quot;PEM format X509 certificate of the sender&amp;quot;
    }
  },
  &amp;quot;required&amp;quot;: [
    &amp;quot;protocol&amp;quot;,
    &amp;quot;message&amp;quot;,
    &amp;quot;signature&amp;quot;,
    &amp;quot;pubcert&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If it&amp;rsquo;s the first time a request is seen from this public cert its verified against
the CA and cached.&lt;/p&gt;

&lt;p&gt;The message is deserialized and the caller id extracted, the matching cert is loaded
from disk and used to validate the signature.  If it passes the deserialized &lt;code&gt;message&lt;/code&gt;
is returned&lt;/p&gt;

&lt;p&gt;The format of a deserialized message is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;{
  &amp;quot;protocol&amp;quot; =&amp;gt; &amp;quot;mcollective:request:3&amp;quot;,
  &amp;quot;message&amp;quot; =&amp;gt; Object,
  &amp;quot;envelope&amp;quot; =&amp;gt; {
    &amp;quot;requestid&amp;quot; =&amp;gt; &amp;quot;bde834cd04835b62a2076b720d6e36d2&amp;quot;,
    &amp;quot;senderid&amp;quot; =&amp;gt; &amp;quot;some.node&amp;quot;,
    &amp;quot;callerid&amp;quot; =&amp;gt; &amp;quot;cert=rip.mcollective&amp;quot;,
    &amp;quot;filter&amp;quot; =&amp;gt; {
      &amp;quot;fact&amp;quot; =&amp;gt; [],
      &amp;quot;cf_class&amp;quot; =&amp;gt; [],
      &amp;quot;agent&amp;quot; =&amp;gt; [&amp;quot;rpcutil&amp;quot;],
      &amp;quot;identity&amp;quot; =&amp;gt; [],
      &amp;quot;compound&amp;quot; =&amp;gt; []},
    },
    &amp;quot;collective&amp;quot; =&amp;gt; &amp;quot;mcollective&amp;quot;,
    &amp;quot;agent&amp;quot; =&amp;gt; &amp;quot;rpcutil&amp;quot;,
    &amp;quot;ttl&amp;quot; =&amp;gt; 60
    &amp;quot;time&amp;quot; =&amp;gt; 1463840020
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the moment the message is YAML serialized before encoding in the JSON that goes to the
connectors but in future versions of MCollective the core message will become JSON safe and
it will be JSON encoded instead.&lt;/p&gt;

&lt;p&gt;Eventually this &lt;code&gt;mcollective:request:3&lt;/code&gt; will become the core MCollective protocol, for now
this is converted into the current MCollective protocol and goes to become a &lt;code&gt;MCollective::Message&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;{
  :body =&amp;gt; request[&amp;quot;message&amp;quot;],
  :senderid =&amp;gt; request[&amp;quot;envelope&amp;quot;][&amp;quot;senderid&amp;quot;],
  :requestid =&amp;gt; request[&amp;quot;envelope&amp;quot;][&amp;quot;requestid&amp;quot;],
  :filter =&amp;gt; request[&amp;quot;envelope&amp;quot;][&amp;quot;filter&amp;quot;],
  :collective =&amp;gt; request[&amp;quot;envelope&amp;quot;][&amp;quot;collective&amp;quot;],
  :agent =&amp;gt; request[&amp;quot;envelope&amp;quot;][&amp;quot;agent&amp;quot;],
  :callerid =&amp;gt; request[&amp;quot;envelope&amp;quot;][&amp;quot;callerid&amp;quot;],
  :ttl =&amp;gt; request[&amp;quot;envelope&amp;quot;][&amp;quot;ttl&amp;quot;],
  :msgtime =&amp;gt; request[&amp;quot;envelope&amp;quot;][&amp;quot;time&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;puppet-security-plugin-reply&#34;&gt;Puppet Security Plugin Reply&lt;/h3&gt;

&lt;p&gt;The following is a reply encoded for delivery using the communication plugins, it
will be JSON encoded before sending:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;$schema&amp;quot;: &amp;quot;http://json-schema.org/draft-04/schema#&amp;quot;,
  &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
  &amp;quot;properties&amp;quot;: {
    &amp;quot;protocol&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
      &amp;quot;enum&amp;quot;: [
        &amp;quot;mcollective::security::choria:reply:1&amp;quot;
      ]
    },
    &amp;quot;message&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
      &amp;quot;description&amp;quot;: &amp;quot;YAML encoded mcollective:reply:3&amp;quot;
    },
    &amp;quot;hash&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
      &amp;quot;description&amp;quot;: &amp;quot;SHA256 has of the message&amp;quot;
    }
  },
  &amp;quot;required&amp;quot;: [
    &amp;quot;protocol&amp;quot;,
    &amp;quot;message&amp;quot;,
    &amp;quot;hash&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The format of the deserialized message is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;{
  &amp;quot;protocol&amp;quot; =&amp;gt; &amp;quot;mcollective:reply:3&amp;quot;,
  &amp;quot;message&amp;quot; =&amp;gt; Object,
  &amp;quot;envelope&amp;quot; =&amp;gt; {
    &amp;quot;senderid&amp;quot; =&amp;gt; &amp;quot;some.node&amp;quot;,
    &amp;quot;requestid&amp;quot; =&amp;gt; &amp;quot;bde834cd04835b62a2076b720d6e36d2&amp;quot;,
    &amp;quot;agent&amp;quot; =&amp;gt; &amp;quot;rpcutil&amp;quot;,
    &amp;quot;time&amp;quot; =&amp;gt; 1463840021
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eventually this &lt;code&gt;mcollective:reply:3&lt;/code&gt; will become the core MCollective protocol, for now
this is converted into the current MCollective protocol and goes on to become a &lt;code&gt;MCollective::Message&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;{
  :senderid =&amp;gt; reply[&amp;quot;envelope&amp;quot;][&amp;quot;senderid&amp;quot;],
  :requestid =&amp;gt; reply[&amp;quot;envelope&amp;quot;][&amp;quot;requestid&amp;quot;],
  :senderagent =&amp;gt; reply[&amp;quot;envelope&amp;quot;][&amp;quot;agent&amp;quot;],
  :msgtime =&amp;gt; reply[&amp;quot;envelope&amp;quot;][&amp;quot;time&amp;quot;],
  :body =&amp;gt; reply[&amp;quot;message&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>